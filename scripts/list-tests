#!/bin/bash

# List tests script for the uber project
# Usage: list-tests [package_pattern]
#   - If no arguments provided, lists all tests in all packages
#   - If package_pattern provided, lists tests in matching packages

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Function to print colored output
print_info() {
  echo -e "${BLUE}ℹ️  $1${NC}"
}

print_success() {
  echo -e "${GREEN}✅ $1${NC}"
}

print_warning() {
  echo -e "${YELLOW}⚠️  $1${NC}"
}

print_error() {
  echo -e "${RED}❌ $1${NC}"
}

print_header() {
  echo -e "${CYAN}$1${NC}"
}

# Use UBER_PROJECT_ROOT if available (when run through uber)
# Otherwise fall back to calculating it from script location
if [ -n "$UBER_PROJECT_ROOT" ]; then
  PROJECT_ROOT="$UBER_PROJECT_ROOT"
  print_info "Using uber project root: $PROJECT_ROOT"
else
  # Fallback for direct execution
  SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
  PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
  print_warning "UBER_PROJECT_ROOT not set, using calculated project root: $PROJECT_ROOT"
fi

# Change to project root
cd "$PROJECT_ROOT"

# Check if Go is available
if ! command -v go &>/dev/null; then
  print_error "Go is not installed or not in PATH"
  exit 1
fi

# Function to list tests in a package
list_tests_in_package() {
  local package_path="$1"
  local package_name=$(basename "$package_path")

  print_header "\n📦 Package: $package_path"

  # Get all tests in the package
  local tests=$(go test -list . "$package_path" 2>/dev/null | grep -E "^Test[A-Z]" | sort)

  if [ -z "$tests" ]; then
    print_warning "  No tests found in this package"
    return
  fi

  # Count tests
  local test_count=$(echo "$tests" | wc -l)
  print_info "  Found $test_count test(s):"

  # List each test
  echo "$tests" | while IFS= read -r test; do
    echo "    • $test"
  done
}

# Function to list all tests
list_all_tests() {
  print_header "🔍 Available Tests in uber project"
  print_info "Project root: $PROJECT_ROOT"
  echo

  # Find all Go packages with test files
  local packages=$(find . -name "*_test.go" -type f | sed 's|/[^/]*_test\.go$||' | sort -u | grep -v "^\.$")

  if [ -z "$packages" ]; then
    print_warning "No test files found in the project"
    return
  fi

  local total_tests=0

  # List tests in each package
  while IFS= read -r package; do
    # Convert relative path to Go package path
    local go_package=$(echo "$package" | sed 's|^\./||' | sed 's|/|/|g')

    # Get test count for this package
    local package_tests=$(go test -list . "./$package" 2>/dev/null | grep -E "^Test[A-Z]" | wc -l)
    total_tests=$((total_tests + package_tests))

    list_tests_in_package "./$package"
  done <<<"$packages"

  echo
  print_success "Total tests found: $total_tests"
}

# Function to list tests in specific packages
list_tests_in_pattern() {
  local pattern="$1"

  print_header "🔍 Tests matching pattern: $pattern"
  print_info "Project root: $PROJECT_ROOT"
  echo

  # Find packages matching the pattern
  local packages=$(find . -name "*_test.go" -type f | sed 's|/[^/]*_test\.go$||' | sort -u | grep -E "$pattern" | grep -v "^\.$")

  if [ -z "$packages" ]; then
    print_warning "No packages found matching pattern: $pattern"
    return
  fi

  local total_tests=0

  # List tests in matching packages
  while IFS= read -r package; do
    # Get test count for this package
    local package_tests=$(go test -list . "./$package" 2>/dev/null | grep -E "^Test[A-Z]" | wc -l)
    total_tests=$((total_tests + package_tests))

    list_tests_in_package "./$package"
  done <<<"$packages"

  echo
  print_success "Total tests found: $total_tests"
}

# Main logic
if [ $# -eq 0 ]; then
  # No arguments provided, list all tests
  list_all_tests
else
  # Arguments provided, list tests in matching packages
  list_tests_in_pattern "$1"
fi

print_success "Test listing completed!"
